use wasm_bindgen::prelude::*;

pub fn is_e(m: &[f32; 16]) -> bool {
  if m[0] == 1.0
    && m[1] == 0.0
    && m[2] == 0.0
    && m[3] == 0.0
    && m[4] == 0.0
    && m[5] == 1.0
    && m[6] == 0.0
    && m[7] == 0.0
    && m[8] == 0.0
    && m[9] == 0.0
    && m[10] == 1.0
    && m[11] == 0.0
    && m[12] == 0.0
    && m[13] == 0.0
    && m[14] == 0.0
    && m[15] == 1.0 {
    return true
  }
  false
}


pub fn assign_m(m1: &mut [f32; 16], m2: &[f32; 16]) -> () {
  m1[0] = m2[0];
  m1[1] = m2[1];
  m1[2] = m2[2];
  m1[3] = m2[3];
  m1[4] = m2[4];
  m1[5] = m2[5];
  m1[6] = m2[6];
  m1[7] = m2[7];
  m1[8] = m2[8];
  m1[9] = m2[9];
  m1[10] = m2[10];
  m1[11] = m2[11];
  m1[12] = m2[12];
  m1[13] = m2[13];
  m1[14] = m2[14];
  m1[15] = m2[15];
}

pub fn multiply2(m1: &[f32; 16], m2: &[f32; 16], m: &mut [f32; 16]) -> () {
  if is_e(m1) {
    assign_m(m, m2);
  }
  else if is_e(m2) {
    assign_m(m, m1);
  }
  else {
    for i in 0..4 {
      let a0 = m1[i];
      let a1 = m1[i + 4];
      let a2 = m1[i + 8];
      let a3 = m1[i + 12];
      m[i] = a0 * m2[0] + a1 * m2[1] + a2 * m2[2] + a3 * m2[3];
      m[i + 4] = a0 * m2[4] + a1 * m2[5] + a2 * m2[6] + a3 * m2[7];
      m[i + 8] = a0 * m2[8] + a1 * m2[9] + a2 * m2[10] + a3 * m2[11];
      m[i + 12] = a0 * m2[12] + a1 * m2[13] + a2 * m2[14] + a3 * m2[15];
    }
  }
}
